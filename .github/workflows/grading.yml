name: 파일 입출력 프로그램 채점 (Fruit Info) - 입력 파일 이름 및 내용 사용 검증

on: [push]

jobs:
  grade:
    runs-on: ubuntu-latest
    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v3

      - name: 채점 스크립트 실행
        id: grading
        run: |
          # ANSI 색상 코드 정의
          GREEN='\033[32m'
          RED='\033[31m'
          NC='\033[0m'
          
          SCORE=0
          FINAL_FEEDBACK=""
          TEST_COUNT=0
          PASS_COUNT=0
          
          INPUT_FILE="fruits.txt" 
          EXPECTED_OUTPUT_FILE="fruit_info.txt"
          
          # 함수: 불필요한 공백과 빈 줄을 제거하고 엄격하게 비교
          normalize_output() {
            tr -d '\r' < "$1" | 
            sed 's/^[[:space:]]*//; s/[[:space:]]*$//g' | 
            tr -s '[:space:]' ' ' | 
            grep -v '^\s*$' |
            tr '[:upper:]' '[:lower:]'
          }
          
          echo "::group::테스트 환경 설정 및 컴파일"
          
          # --- 0. 초기화 ---
          rm -f "${EXPECTED_OUTPUT_FILE}" "${INPUT_FILE}" *.txt *.o main
          FINAL_FEEDBACK="[OK] 작업 공간 초기화 완료.\n"
          
          # --- 1. 컴파일 시도 ---
          if ! gcc main.c -o main 2> compile_error.txt; then
            FINAL_FEEDBACK="${RED}[FAIL]${NC} 컴파일 실패. 코드를 확인하세요.\n"
            FINAL_FEEDBACK="${FINAL_FEEDBACK}  [컴파일 오류 메시지]:\n$(cat compile_error.txt)\n"
            echo "::error::채점 실패: 컴파일 오류."
            echo "::endgroup::"
            
            # 최종 점수 0점 처리 및 종료
            echo "score=0" >> "$GITHUB_OUTPUT"
            echo "feedback<<EOF" >> "$GITHUB_OUTPUT"
            echo -e "$FINAL_FEEDBACK" >> "$GITHUB_OUTPUT"
            echo "EOF" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          FINAL_FEEDBACK="${FINAL_FEEDBACK}[OK] 컴파일 성공.\n"
          echo "::endgroup::"
          
          # --------------------------------------------------------------------------
          #  핵심 검증 로직: 2단계 테스트 실행 
          #  => 'fruits.txt' 파일 이름을 정확히 사용하고 그 내용에 따라 출력이 달라지는지 강제 확인
          # --------------------------------------------------------------------------

          # 테스트 케이스 배열 정의: {입력 파일 내용} | {기대하는 출력 파일 내용}
          # Test 1과 Test 2의 입력 파일 내용이 다르므로, 학생 코드가 'fruits.txt'를 정확히 읽지 않으면
          # Test 2에서 반드시 FAIL이 발생하여 0점이 됩니다.
          declare -a TEST_CASES=(
            "1,Apple,Red,15000\n2,Banana,Yellow,10000\n3,Melon,Green,32000\n4,Grape,Purple,18000|offset: 2\nname: Melon\ncolor: Green\nprice: 32000"
            "10,KIWI,BROWN,500\n20,PEAR,YELLOW,2000\n30,PINEAPPLE,GOLD,80000\n40,MANGO,ORANGE,12000|offset: 3\nname: MANGO\ncolor: ORANGE\nprice: 12000"
          )
          
          for TEST_CASE in "${TEST_CASES[@]}"; do
            TEST_COUNT=$((TEST_COUNT + 1))
            
            INPUT_CONTENT=$(echo -e "${TEST_CASE}" | cut -d'|' -f1)
            EXPECTED_CONTENT=$(echo -e "${TEST_CASE}" | cut -d'|' -f2)
            
            echo "::group::[TEST ${TEST_COUNT}] 새로운 입력 파일 생성 및 실행"
            
            # 1. 입력 파일 생성 (fruits.txt)
            echo -e "${INPUT_CONTENT}" > "${INPUT_FILE}"
            FINAL_FEEDBACK="${FINAL_FEEDBACK}\n--- [TEST ${TEST_COUNT}] 시작 (입력 파일 내용 변경) ---\n"
            FINAL_FEEDBACK="${FINAL_FEEDBACK}  [생성된 ${INPUT_FILE} 내용]:\n$(echo -e "${INPUT_CONTENT}")\n"

            # 2. 기대 출력 파일 생성 (비교 기준)
            echo -e "${EXPECTED_CONTENT}" > expected_output.txt
            
            # 3. 이전 출력 파일 삭제 (실행 전 초기화)
            rm -f "${EXPECTED_OUTPUT_FILE}"
            
            # 4. 프로그램 실행 (학생 코드가 fruits.txt를 읽고 fruit_info.txt를 생성해야 함)
            if ! ./main; then
              FINAL_FEEDBACK="${FINAL_FEEDBACK}${RED}[FAIL]${NC} [TEST ${TEST_COUNT}] 프로그램 런타임 오류 또는 비정상 종료.\n"
              echo "::error::[TEST ${TEST_COUNT}] 프로그램 런타임 오류."
              echo "::endgroup::"
              continue
            fi
            
            # 5. 결과 파일 확인 및 비교
            if [ -f "${EXPECTED_OUTPUT_FILE}" ]; then
              
              EXPECTED_NORMALIZED="$(normalize_output expected_output.txt)"
              ACTUAL_NORMALIZED="$(normalize_output "${EXPECTED_OUTPUT_FILE}")"
              
              if [[ "$ACTUAL_NORMALIZED" == "$EXPECTED_NORMALIZED" ]]; then
                PASS_COUNT=$((PASS_COUNT + 1))
                FINAL_FEEDBACK="${FINAL_FEEDBACK}${GREEN}[PASS]${NC} [TEST ${TEST_COUNT}] 출력 파일 내용 일치. (입력 파일 사용 증명)\n"
              else
                FINAL_FEEDBACK="${FINAL_FEEDBACK}${RED}[FAIL]${NC} [TEST ${TEST_COUNT}] 출력 파일 내용 불일치.\n"
                FINAL_FEEDBACK="${FINAL_FEEDBACK}  [기대하는 내용 (정규화됨)]: $EXPECTED_NORMALIZED\n"
                FINAL_FEEDBACK="${FINAL_FEEDBACK}  [학생 프로그램 생성 내용 (정규화됨)]: $ACTUAL_NORMALIZED\n"
                echo "::error::[TEST ${TEST_COUNT}] 생성된 파일 내용 불일치. 입력 파일('fruits.txt')의 데이터를 제대로 읽었는지 확인하세요."
              fi
            else
              FINAL_FEEDBACK="${FINAL_FEEDBACK}${RED}[FAIL]${NC} [TEST ${TEST_COUNT}] ${EXPECTED_OUTPUT_FILE} 파일이 생성되지 않았습니다.\n"
              echo "::error::[TEST ${TEST_COUNT}] 기대하는 결과 파일(${EXPECTED_OUTPUT_FILE})이 없습니다."
            fi
            
            echo "::endgroup::"
          done
          
          # ----------------------------------------------------
          #                       최종 점수 계산
          # ----------------------------------------------------
          
          if [ "$PASS_COUNT" -eq "$TEST_COUNT" ]; then
            SCORE=100
            FINAL_FEEDBACK="${FINAL_FEEDBACK}\n${GREEN}[최종 결과] 모든 테스트 (${TEST_COUNT}개) 통과: 100점${NC}"
          else
            # 오타 코드(예: frui.txt)를 사용한 경우, Test 2에서 반드시 FAIL이 발생하여 0점 처리됨
            SCORE=0
            FINAL_FEEDBACK="${FINAL_FEEDBACK}\n${RED}[최종 결과] 일부 테스트 실패 (${PASS_COUNT}/${TEST_COUNT} 통과): 0점${NC}"
          fi

          # GitHub Classroom 최종 점수 및 피드백 전달
          echo "score=$SCORE" >> "$GITHUB_OUTPUT"
          echo "feedback<<EOF" >> "$GITHUB_OUTPUT"
          echo -e "$FINAL_FEEDBACK" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          
          # 점수가 100점이 아니면 GitHub Actions 작업을 실패 처리
          if [ "$SCORE" -ne 100 ]; then
              exit 1
          fi